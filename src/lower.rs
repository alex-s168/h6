use crate::bytecode::*;
use crate::parse::Expr;

pub trait Position {
    fn pos(&self) -> usize;
}

impl<T> Position for Vec<T> {
    fn pos(&self) -> usize {
        self.len()
    }
}

/// writes a bytecode assembly WITHOUT THE HEADER
/// after calling this, the HEADER HAS TO BE PREPENDED to the generated bytes
pub fn lower<'src, W: std::io::Write + Position>(sink: &mut W, exprs: Vec<Expr<'src>>) -> [u8;16] {
    // we keep track of all previously defined bindings.
    // this will keep references to later-defined bindings as Unresolved, which the runtime's linker will resolve

    let globals_tab_num = 0_usize;
    let globals_tab_off = 0_usize;

    let mut header = [
        'H' as u8, '6' as u8, 'H' as u8, '6' as u8,
        1_u8, // min reader version
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ];

    header[6..8].copy_from_slice(&(globals_tab_num as u16).to_le_bytes());
    header[8..12].copy_from_slice(&(globals_tab_num as u32).to_le_bytes());

    header
}