use std::collections::HashMap;
use itertools::Itertools;
use crate::lex::{Tok, TokStr};
use crate::parse::Expr;
use h6_bytecode::*;

pub trait Position {
    fn pos(&self) -> usize;
}

impl<T> Position for Vec<T> {
    fn pos(&self) -> usize {
        self.len()
    }
}

pub struct PosWriter<'a, W: std::io::Write> {
    pos: usize,
    sink: &'a mut W
}

impl<'a, W: std::io::Write> PosWriter<'a, W> {
    pub fn new(sink: &'a mut W) -> Self {
        Self { pos: 0, sink }
    }
}

impl<W: std::io::Write> std::io::Write for PosWriter<'_, W> {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        self.pos += buf.len();
        self.sink.write(buf)
    }
    fn flush(&mut self) -> std::io::Result<()> {
        self.sink.flush()
    }
}

impl<W: std::io::Write> Position for PosWriter<'_, W> {
    fn pos(&self) -> usize {
        self.pos
    }
}

pub fn lower_full<'src: 'l, 'l, W, I, G>(sink: &mut W, toks: &G, exprs: I) -> std::io::Result<()>
where W: std::io::Write + std::io::Seek,
      I: Iterator<Item = &'l Expr<'src>>,
      G: std::ops::Index<usize, Output = Tok<'src>>
{
    let begin = sink.stream_position()?;
    sink.write_all(&[0_u8;16])?;
    let header = lower(&mut PosWriter::new(sink), toks, exprs)?;
    sink.seek(std::io::SeekFrom::Start(begin))?;
    sink.write_all(&header)?;
    Ok(())
}

/// writes a bytecode assembly WITHOUT THE HEADER
/// after calling this, the HEADER HAS TO BE PREPENDED to the generated bytes
/// the Position getter should NOT INCLUDE THE 16B HEADER
pub fn lower<'src: 'l, 'l, W, I, G>(sink: &mut W, toks: &G, exprs: I) -> std::io::Result<[u8;16]>
where W: std::io::Write + Position,
      I: Iterator<Item = &'l Expr<'src>>,
      G: std::ops::Index<usize, Output = Tok<'src>>
{
    // we keep track of all previously defined bindings.
    // this will keep references to later-defined bindings as Unresolved, which the runtime's linker will resolve

    let mut globals = HashMap::<TokStr, u32>::new();
    let mut main_ops = Vec::<Op>::new();

    let resolve = |sink: &mut W, globals: &HashMap<TokStr, u32>, tok: u32| -> std::io::Result<Op> {
        let str = match &toks[tok as usize] {
            Tok::Ident(str) => str,
            _ => panic!("ident expr points invalid token")
        };

        match globals.get(str) {
            Some(pos) => Ok(Op::Const { idx: *pos }),

            None => {
                let p = sink.pos() as u32;
                sink.write_all(str.as_bytes())
                    .and_then(|_| sink.write_all(&[0_u8]))?;
                Ok(Op::Unresolved { id: p })
            }
        }
    };

    // TODO: main_ops and globals
    for expr in exprs {
        let mut write_ops = expr.val.iter()
            .map(|x| {
                match x {
                    Op::Unresolved { id } => resolve(sink, &globals, *id),
                    x => Ok(x.clone())
                }
            }).collect::<std::io::Result<Vec<_>>>()?;

        match &expr.binding {
            Some(name) => {
                let p = sink.pos() as u32;

                for op in write_ops {
                    op.write(sink)?;
                }
                Op::Terminate.write(sink)?;

                globals.insert(name.clone(), p);
            }

            None => {
                main_ops.append(&mut write_ops);
            }
        }
    }
    
    let globals_tab_num = globals.len();

    let globals = globals
        .into_iter()
        .map(|(k,v)| {
            let p = sink.pos();
            sink.write_all(k.as_bytes())
                .and_then(|_| sink.write_all(&[0_u8]))
                .map(|_| {
                    let mut o = [0_u8; 8];
                    o[0..4].copy_from_slice((p as u32).to_le_bytes().as_slice());
                    o[4..8].copy_from_slice(&v.to_le_bytes().as_slice());
                    o
                })
        })
        .process_results(|x|
            x.flatten().collect::<Vec<_>>())?;

    let globals_tab_off = sink.pos();
    sink.write_all(&globals)?;

    for op in main_ops {
        op.write(sink)?;
    }
    Op::Terminate.write(sink)?;

    let mut header = [
        'H' as u8, '6' as u8, 'H' as u8, '6' as u8,
        1_u8, // min reader version
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ];

    header[6..8].copy_from_slice(&(globals_tab_num as u16).to_le_bytes());
    header[8..12].copy_from_slice(&(globals_tab_off as u32).to_le_bytes());

    Ok(header)
}
